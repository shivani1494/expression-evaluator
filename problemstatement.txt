The scientists at DataCorp craft complex formulas over time and they would like to have a system that helps them iterate on their science. You are responsible to help the team by building a system that:
Is able to evaluate arithmetic expressions
Is able to provide visualizations of arithmetic expressions
Scales to handle millions of complex expressions with low latency.

An arithmetic expression:
- contains numbers, unary operators (+/-), binary operators (+,-,*,/, ^ exp, log) and parenthesis.
- can be arbitrarily complex (thousands of operations)
- is given as a string

You need to implement a service, that given a large set of expressions can:
Print each of them as an expression tree (https://en.wikipedia.org/wiki/Binary_expression_tree)
Evaluate all expressions and provide the results

Some considerations:
There are libraries available to parse and evaluate expressions (e.g for python) . Using such a library is optional, but if you do we are interested in: how efficient is the evaluation and can you do 2 performance improvements (latency of evaluating the set of expressions and/or total CPU used to evaluate expressions) on top of it.
How would you go about evaluating the performance of your solution?
(And if someone were to suggest further improvements, what would you have them do to evaluate their change?)
If you choose to write your own expression evaluator, what are the data structures you would use to represent expressions and how would you reuse state across expressions?
Finessing the pretty printing of expressions is a non-goal. Please provide a visualization that is clear enough but don’t spend too much time on it beyond a basic layout if that saves you time.

The absolute performance that you end up with is of less interest to us than the process and the evaluation methodology.

For example:

Input:
log(3.5,2) + 1.2 ^ (4 - ½) + 100 * 3





Expression tree (representation is not unique):
                          “+”
                      /            \
	    “log”             “+”
               /     \            /        \
             3.5     2      “^”           “*”
                             /      \       /       \
	            “1.2”    “ -”  “100”  “3”
                              /        \                  
		   “4”       “/”
			/      \
                                “1”       “2”

Evaluation: 
303.700284081

Test Data: 
Each line in the file pasted below contains one expression. You are asked to write a program that outputs the score and expression tree for each of the test expressions (we recommend a file for each input expression). We are also interested in the unit tests and microbenchmarks you write to evaluate the program correctness and performance.

We are deeply appreciative of the time you’re willing to spend on this. Thank you! Please do not spend more than a few hours on this and feel free to aggressively adjust the scope of this open-ended problem to fit the time you’d like to spend on it.

Sample input file:
1
1 + 1
- 1 + 2 - 3 * 4 / 5 ^ 6 
log(10.5,2)
log(10.5,2) + log(10.5,2)
log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2)
log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2)
log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2) + log(10.5,2)
(log(((((((((100 - 1) * 2) + 3) - 4) / 5) ^ 6) - 7) + 8), 2) - 1) + 4
1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1


